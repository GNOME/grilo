Interesting services (examples)
--------------------------------

youtube
flickr
last.fm
local
upnp

bluetooth
podcast
radio directory
internet tv
radio fm
ipod
sintonizador tv
webcam

------------------------------------------------------------------

1.- Define basic source API
   -> browse()
   -> metadata()
   -> store()
   -> remove()
   -> auth() (i.e. youtube upload)
   -> ...

2.- Sources should expose a set of properties
   -> example youtube: a property for the search text, or the category, etc
     -> Using special parameter in methods is not so flexible
   -> Basic set of well known metadata defined at fw level (author, artist, album, date, etc)
   -> A source plugin does not have to implement all metadata

3.- Source must provide some metadata like the URL fo the content, but not necesarily everything.

4.- Metadata providers can specialize on metadata. They register the keys the can provide in the fw.
    -> Priorities for metadata providers and sources.

5.- Source should allow to create new categories (using a string parameter)
    -> youtube (using a search string)
    -> Last.FM (using a string representing a prototype author)
    -> Local Metadata (using a metadata based search string)
    -> Local FS (using a path representing a directory)
 
    -> How this string is interpreted is plugin dependent
    -> The plugin "decodes" this string and registers the new category.
    -> Provide means for the plugins to manage their categories
       -> Probably an xml file and utilities to read and write it easily.

1.- Define a basic set of metadata keys
     -> author, artist, album, title, uri, etc
     -> New plugins could add new metadata that is not standar (defined at fw level) by registering it.

2.- Define API
     -> Define basic APIs: browse(), getMetadata(), search() -> Similar style to the ones existing in mafw, search() would search using
        a search string (usefult for things like youtube).
        -> Provide async implementation of these APIs at the framework level (source developers do not ave to care about this).
        -> Same for result emission (framework could take care of that).
     -> Define extended APIs: upload(), createCategory(), remove(), etc
       -> creating categories is plugin specific:
          -> youtube: a category could be a search string, or a youtube category, or both
          -> Last.FM: a category could be a string representing a target artist (for artists similar to....) or similar use cases.
          -> Local Content (Metadata): A category would be a metadata query (for example artist=whatever and genre=whatever)
          -> Local Content (Filesystem): A category would be a directory in the FS.
       -> Not all the sources would allow creating new categories (exmaple: upnp, ipod, etc).
       -> store() would move content from local to source (example: uploading a video to youtube).
       -> Some operations may need auth info.
     -> Sources can store its exposed structure in an xml file, and the fw provides utilities to manage that structure.
        -> Example, youtube 
        <category id="TopRated">
          <uiname>Top Rated Videos</uiname>
          <query>http://gdata.youtube.com/feeds/standardfeeds/top_rated</query>
        </category>
        <category id="RecentlyFeatured">
          <uiname>Recently Featured Videos</uiname>
          <query>http://gdata.youtube.com/feeds/standardfeeds/Recently Featured</query>
        </category>
        <category id="IgaliaVideos">
          <uiname>Videos of Igalia</uiname>
          <query>http://gdata.youtube.com/feeds/api/videos?q=igalia&v=2</query>
        </category>
     -> Not all sources have to support/implemet all operations.
        -> Sources provide info on what operations they support.

3.- Metadata Providers
       -> Only provide metadata information. 
       -> There must be some kind of priorities for metadata providers and/or a fallback mechanism.
       -> examples of metadata providers: ratings, lyrics, etc.
       
	Use case: youtube provides ratings, but local content does not, how would a ratings plugin work
        on a youtube source? Should we use youtube's ratings or the plugin's? Should we rate the movie
        and store the result in youtube or in the plugin? Or should both be separate things (different
	metadata keys)?

        What to use as key of the media here? the file name? a hash? can we obtian the hash for all sources
	easily?

4.- There is a plugin registry.
    -> The registry must store info about the plugin (ala gstreamer).
       -> Plugin name, description, UI name, Author, Web, License, etc
    -> Tool for scanning available plugins (ala gst-inspect).
    -> API for accessing the available plugins, filtering them, etc
    
5.- run the plugin queries in a separate thread? => framework should provide means to deal with this sanely.
    or use mainloop? => In any case, the framework should take care of it.

6.- Plugins may expose properties to configure its behavior
    -> Example: youtube's search string
    -> Example: youtube categories for the search
    -> Example: Last.FM's string for artists similar to...
    -> Another option: the source stablishes the categories by fixing them in the xml file and provides means
       to users to create new categories by calling createCategory() method.
       -> Benefit: API not so convoluted, problem is simplified a lot and probably it is flexible enough for most cases.
       -> It fits with the browse() idea (using properties would be more in the "searchByText() idea"

7.- Browse()/Search() results are stored in a playlist-style object that can be used easily (hashtables).


-------------- 8< --------------------- 8< ---------------------- 8< ------------------------

RadioFM

  -> Escribir en un fichero dev los parametros del sintonizador ioctl().
  -> La lectura del audio se hace desde un fichero de dispositivo
     -> Nosotros tenemos que hacer proxy de eso mendiante una URL que es la que proporcionamos en un getmetadata
  -> Al inicio, el plugin podria hacer un barrido de frecuencias y exponerlas como su listado de contenidos.

Flickr, Last.FM

  -> Similar a youtube

Framework

  -> Implementar search en vez de browse, las aplicaciones implementan su propio arbol.
    -> Implementar search y de esa forma los clientes pueden definir su arbol programaticamente, sin necesidad de browse.
  -> Source a devolver playlist que se pueden modelar con el patron agregacion (playlists de playlist).


----------------------- X --------------------------- x -------------------------- X ----------------------

MediaSource
   -> Browse muy sencillo: sin filtros, sin recursividad
     -> Podemos añadir versiones mas complejas en forma de nuevas APIs (browse_complex que filtre y ordene).
     -> O incluso simplemente un API search() que se encargue de implementar consultas mas complejas.
       -> Mejor porque no todos los plugins tienen que soportar recursividad (que ademas añade cierta complejidad)
          y hace el API de browsing mas ligera.
       -> Los desarrolladores de los plugins mas sencillos (e.g. browsing de sistema de ficheros por directorios)
          no se tienen que preocupar de gestionar cosas que no van a implementar, simplemente implementan browse 
          y no implementan search.
   -> IDEA: Podriamos eliminar el parametro count y hacer que browse()/search() devolvieses un iterador/contenedor inteligente
            El callback del browse solo devuelve el iterador/contenedor y solo se llama 1 vez a partir de ese punto es el cliente
	    el que itera sobre los resultados y el iterador inteligente control el offset y el count, etc
            seria muy util por ejemplo al hacer browsing de servicios pesados como bluetooth, que pueden requerir hacer el browsing 
            de forma diferente para hacerlo eficiente.
            De todas formas el mismo plugin podria hacer consultas mas grandes o mas pequeñas dependiendo de lo que se quiera hacer en la UI
            no es lo mismo hacer un browse de songs para mostrar todas las canciones de golpe que si se sabe que la UI esta haciendo un 
            browse de songs para mostrar los resultados por paginas (en el segundo caso es mas eficiente consultas pequeñas, mientra que en el
	    primero lo optimo seria tender a consultas mas grandes y hacer menos consultas).
   -> Podria ser interesante pensar en definir un tipo "Conjunto" para las claves que facilite saber si una clave esta o no en el conjunto.
      -> Util al implementar plugins para saber si se ha pedido o no una clave
      -> Util al implementar capabilities para saber si esta o no una capacidad determinada
   -> Quizas eliminar el API get_metadata() y quedarnos solo con el browse()?
      -> Browse de un container te da los metadatos de los contenidos y del container
      -> Browse de un nodo hoja te da los metadatos del nodo hoja.
   -> MediaPlugin deberia indicar las capacidades del plugin.
      -> Operaciones soportadas
      -> Metadatos soportados
      -> Quizas dos APIs diferentes implementadas a nivel de MediaSource?
         -> El propio MediaSource puede saber que ops estan soportadas simplemente mirando que operaciones virtuales no tienen una implementacion.
         -> Las subclases de MediaSource pueden proporcionar un metodo que de info sobre las claves implementadas que sea obligatorio implementar por las
	    subclases. Lo mismo se emplearia para aquellos plugins que no implementan un source sino que son metadata providers.
            -> Tanto MediaSource como MetadataSource implementan una misma interfaz (la de MetadataSource). 
               -> La interfaz define el metodo get_metadata() y otro para obtener info sobre las claves soportadas por el plugin.
    -> Renombrar clases?
       -> MediaSource --> MediaProvider
       -> MetadataSource --> MetadataProvider
    -> Probablemente necesitemos definir conjuntos y operaciones sobre conjuntos. Por ejemplo, el cliente pide claves A, B y C, y el plugin
       soporta A, C y D. Al final lo más conveniente sería pedirle al plugin A y C directamente, si el conjunto fuese vacío ya no se llamaría al
       plugin. Sería facil para cada clave saber qué plugins la soportan, etc.
        -> Otra posibilidad sería simplemente para cada plugin pasarle la lista y ellos resuelven todo lo que pueden y la consulta se resuelve
	   siempre con valores multivaluados (si varios plugins son capaces de resolver una consulta, se obtienen varios resultados). Los plugins
	   se ordenan por prioridades, etc
    -> Al final los metadatos no se le piden al plugin, sino al framework y este usa los plugins disponibles para obtener los metadatos...
       -> Como encajar esto con browse() y search() que tb resuelven metadatos?
         -> Lo más eficiente es no usar otros plugins, pero no siempre es lo que se desea. Quizas sea necesario confirgurar las operaciones
	    de browse y search para indicar que tipo de comportamiento se requiere?
         -> Definir metadata a nivel del framework tb. Si el cliente hace metadata sobre el plugin, solo se usa el plugin, si lo hace sobre el 
            framework, se usan todos los plugins posibles.
         -> Si se define sobre el framework, qué se le pasa a los plugins?
           -> Necesitamos un mecanismo rapido de conversion objectid -> uri, quizas definir el objectid como una clase en si misma con
	      metodos para su manipulacion de forma que la URI se pueda obtener rapidamente y se obligue a usarla en la codificacion?
              -> Por ejemplo un plugin de ratings podria usar el objectid directamente para almacenar y recuprar ratings puesto que es el el que
                 almacena toda la informacion, sin embargo un plugin de lyrics por ejemplo, no podria, a partir del objectid necesita recuperar otra
		 informacion (artista, album, title...) y usar esa para recabar los datos. Eso implica comunicaciones entre los plugins, el plugin
		 de lyrics ejercerá una consulta de metadata sobre el framework (o el source en particular) preguntando por esos datos.
                 IDEA: modelar dependencias entre claves para hacer este tipo de gestiones de forma eficiente.
    -> Idea hacer comparaciones de claves mas eficiente usando identificadores para cada clave
       -> Definir un rango para claves definidas en el framework (artista, titulo, album, etc)
       -> Dejar otro rango para claves definidas por los plugins que se registran en el fw. 
                 
    -> Playlists y metadata
       -> Las playlists tienen los metadatos, probablemente estos metadatos se obtuvieron por medio de browse() o search().
       -> Al guardar la playlist se guardan tb los metadatos!
          -> Mas espacio, pero la recuperacion de la playlist es inmediata => cargar una playlist no implica tener que volver a
             consultar todos los metadatos de (potencialmente) muchisimos elementos.
          -> si el espacio es un problema (que no deberia), al guardar la playlist se eliminan los metadatos y solo se guardan los
	     objectids, al recuperar la playlist no hay metadatos y el cliente se encarga de demandarlos bajo su propia cuenta y riesgo,
	     sencillo y flexible segun se quiera optimizar eficiencia en disco o en carga.

